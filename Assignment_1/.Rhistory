# install.packages("tableone")
# install.packages("Matching")
# install.packages("tidyverse") #added
# install.packages('rlang')     #added
# Recommended: add "dplyr" if you have used it before to make efficient preprocessing.
library(tableone) # This library allows us to calculate summary statistics about the variables including the SMD (standardized mean difference).
install.packages("tableone")
install.packages("Matching")
install.packages("tidyverse") #added
install.packages('rlang')     #added
# Recommended: add "dplyr" if you have used it before to make efficient preprocessing.
# install.packages("tableone")
# install.packages("Matching")
# install.packages("tidyverse") #added
# install.packages('rlang')     #added
# Recommended: add "dplyr" if you have used it before to make efficient preprocessing.
library(tableone) # This library allows us to calculate summary statistics about the variables including the SMD (standardized mean difference).
library(Matching) # This library will do the matching
library('dplyr')  #added
# Download rhc dataset from CANVAS and read it
rhc <- read.csv("rhc.csv")
print("===================================================")
# => how many rows does rhc contain?
print('The dataset contains 5735 rows')
# => What are the variable names?
print('The 63 variable names are the following below:')
names(rhc)
print("===================================================")
rhc$outcome.died <- as.numeric(rhc$death=='Yes')  # Again you might want, instead, to do all preprocessing with dplyr if you prefer
rhc$treatment.swang <- as.numeric(rhc$swang1=='RHC')
print("===================================================")
# => What is the mean of outcome.died in the whole data set?
print('The mean of outcome.died:')
mean(rhc$outcome.died)
# => How many subjects are treated?
print('The number of treated subjects:')
sum(rhc$swang1=='RHC')
# =>  What is the mean mortality (outcome.died) in this treated group?
print('The mean mortality of treated group:')
mean(rhc$swang1=='RHC' & rhc$outcome.died == 1)
# => How many subjects are not treated (i.e. in the control group)?
print('The number of not treated subjects:')
sum(rhc$swang1=='No RHC')
# => What is the mean mortality in this control group?
print('Mean mortality for not treated:')
mean(rhc$swang1=='No RHC' & rhc$outcome.died == 1)
print("===================================================")
print("===================================================")
# => How many different categories are in Cat1? Tip: use the levels() function on this variable.
rhc$cat1 <- as.factor(rhc$cat1)  #from chr to factor
print('There number of categories in cat1:')
nlevels(rhc$cat1)
print("===================================================")
rhc$ARF <- as.numeric(rhc$cat1=='ARF')
print("===================================================")
# => Do the same (as we did for ARF) also for all other values of cat1 but ignore the category "Missing".
cat1_list <- list(levels(rhc$cat1))
print(cat1_list)
# ------- solution to be optimized later on ---------
rhc$CHF <- as.numeric(rhc$cat1=='CHF')
rhc$Cirrhosis <- as.numeric(rhc$cat1=='Cirrhosis')
rhc$Colon_Cancer <- as.numeric(rhc$cat1=='Colon Cancer')
rhc$Coma <- as.numeric(rhc$cat1=='Coma')
rhc$COPD <- as.numeric(rhc$cat1=='COPD')
rhc$Lung_Cancer <- as.numeric(rhc$cat1=='Lung Cancer')
rhc$MOSF_Malignancy <- as.numeric(rhc$cat1=='MOSF w/Malignancy')
rhc$MOSF_Sepsis <- as.numeric(rhc$cat1=='MOSF w/Sepsis')
print("===================================================")
print("===================================================")
print('We already added the "female" column here instead of later. This way we didnt have to alter the original rhc data and also didnt have to import the "sex" column into rhc.small')
rhc.small <- rhc
rhc.small$female <- as.numeric(rhc.small$sex=='Female')
rhc.small <- rhc.small[,c("ARF", "CHF", "Cirrhosis", "Colon_Cancer", "Coma", "COPD", "Lung_Cancer", "MOSF_Malignancy", "MOSF_Sepsis", "cardiohx", "chfhx", "dementhx", "psychhx",  "chrpulhx", "renalhx", "liverhx",  "gibledhx", "malighx",  "immunhx",  "transhx",  "amihx", "age", "female", "edu", "das2d3pc", "aps1", "scoma1", "meanbp1", "wblc1", "hrt1", "resp1", "temp1", "pafi1", "alb1", "hema1", "bili1", "crea1", "sod1", "pot1",     "paco21", "ph1", "wtkilo1", "dnr1", "resp", "card", "neuro", "gastr",  "renal", "meta", "hema", "seps", "trauma",  "ortho", "adld3p", "urin1", "treatment.swang", "outcome.died")]
print("===================================================")
str(rhc.small)
print("We do not have labelled variables, so we can skip this step.")
#rhc.small$age <- as.numeric(rhc.small$age) # only if in your version of the data "age" was a "labelled" variable
print("===================================================")
# => Change all labelled variables that include numbers (integer or numeric) into numeric.
# print("===================================================")
## rhc.small$female <- as.numeric(rhc.small$sex=='Female')
print("===================================================")
print("We already created the female column earlier because we were required to put it into rhc.small")
#rhc.small$resp<-ifelse(df1$resp=="Yes",1,0)
rhc.small$resp <- as.numeric(rhc.small$resp=='Yes')
rhc.small$card <- as.numeric(rhc.small$card=='Yes')
rhc.small$gastr <- as.numeric(rhc.small$gastr=='Yes')
rhc.small$renal <- as.numeric(rhc.small$renal=='Yes')
rhc.small$hema <- as.numeric(rhc.small$hema=='Yes')
rhc.small$seps <- as.numeric(rhc.small$seps=='Yes')
rhc.small$trauma <- as.numeric(rhc.small$trauma=='Yes')
rhc.small$neuro <- as.numeric(rhc.small$neuro=='Yes')
rhc.small$meta <- as.numeric(rhc.small$meta=='Yes')
rhc.small$ortho <- as.numeric(rhc.small$ortho=='Yes')
rhc.small$dnr1 <- as.numeric(rhc.small$dnr1=='Yes')
# => Change any factor with two values into a 0/1 variable by selecting a value (such as "female" above) to be 1 and the other value will be zero.
print("===================================================")
print("===================================================")
missing <- colMeans(is.na(rhc.small))*100 ##check percentage of NA per column
print(missing)
exclude <- vector(mode = "list", length = 0)
for(colname in names(missing)){
if(missing[[colname]] > 15){ ## if more than 15% of data is missing:
cat(missing[[colname]], colname, '\n')
exclude <- append(exclude, colname) ## contains "adld3p" and "urin1"
}
}
print('Columns to be removed:')
print(exclude)
rhc.small <- rhc.small[, !colnames(rhc.small) %in% exclude]
print("There are no other columns which have any NA's, so step 2 about imputing doesn't apply")
print("===================================================")
print("===================================================")
# => Fit logistic regression models for each variable separately with the outcome and retain those with an association having a p-value of â‰¤ 0.1. Tip: you may want to automate the whole process!
xvars <- vector(mode = "list", length = 0)
for(i in seq_along(rhc.small)){
if(names(rhc.small[i]) == 'treatment.swang' || names(rhc.small[i]) == 'outcome.died'){
next
}
mod <- as.formula(sprintf("outcome.died ~ %s", names(rhc.small[i])))
model <- glm(formula = mod, family = binomial, data = rhc.small)
pValue <- coef(summary(model))[,'Pr(>|z|)']
pValue <- pValue[2]
if(pValue <= 0.1){
xvars <- append(xvars, names(rhc.small[i]))
}
}
# => Put the names of the selected variables (without the treatment and outcome variables) in the variable xvars by writing xvars <- c("ARF", ...) or do it automatically as described in the tip.
# => Put these selected variables in a data.frame called 'rhc.selected' that also includes the treatment and outcome variables to this data frame.
idx <- match(xvars, names(rhc.small))
rhc.selected <- rhc.small[,idx]
rhc.selected$treatment.swang <- rhc.small$treatment.swang
rhc.selected$outcome.died <- rhc.small$outcome.died
print("===================================================")
xvars <- unlist(xvars)  #if necessary use 'unlist' so it is a vector instead of a list
print("===================================================")
#=> look at "table 1", complete the command by filling in the "..."
table1<- CreateTableOne(vars=xvars, strata='treatment.swang', data=rhc.selected, test=FALSE)
## include standardized mean difference (SMD)
#print(table1, smd=TRUE)
## For which variables we do not have a good balance? Look at the slides for a guideline.
#As mentioned in slide 102, variables that have a serious imbalance are the ones with SMD > 0.2
addmargins(table(ExtractSmd(table1) > 0.2)) #counting number of variables with SMD > 0.2 (=12)
#creating a dataframe to extract those variables
df_smd <- data.frame(variable = rownames(ExtractSmd(table1)),
Unmatched = as.numeric(ExtractSmd(table1)))
print('Variables with smd > 0.2:')
df_smd$variable[df_smd$Unmatched>0.2]
print("===================================================")
print("===================================================")
# We want to match the treated with the untreated subjects. Find 1 on 1 match.
# # => Complete the command
treatment <- as.numeric(rhc.selected$treatment.swang==1)
greedymatch <- Match(Tr=treatment, M=1,X=rhc.selected[xvars], replace=FALSE)
# read the documentation for Match() by typing ?Match.
# => What does replace=FALSE mean?
print(" 'replace=FALSE' means that the order of matches matters as they will be founded in the same way the data are ordered so this introduces more bias.")
# => What is inside X?
print('Inside X there is the matrix containing the variables we wish to match on.')
rhc.selected[xvars]
print("===================================================")
?Match #useful to read the documentation for Match()
print("===================================================")
greedymatch$index.treated # => What do you think this is?
print('This is who are the treated and their ID variable')
greedymatch$index.control # => What do you think this is?
print('This is who are the controls and their ID variable.')
print("===================================================")
matched <- rhc.selected[unlist(greedymatch[c("index.treated","index.control")]), ]
matched[1,]  # This is the first treated subject
print("===================================================")
matched[length(greedymatch$index.treated)+1,] # => What do you think this subject is?
print("untreated. the index = length gives us the last treated person in the list, when our index exceeds the list length it continues with the people where treated = 0")
print("===================================================")
print("===================================================")
# => Complete the command to create table 1 after matching
matchedtab1 <-  CreateTableOne(vars=xvars, strata='treatment.swang', data=matched, test=FALSE)
# => Print the balance with smd.
print(matchedtab1, smd = TRUE)
# => After matching how many "bad" variables with SMD > 0.2 are there?
addmargins(table(ExtractSmd(matchedtab1) > 0.2)) ## 3
print("There are 3 'bad' variables: meanbp1, aps1 and crea1")
print("===================================================")
print("===================================================")
# => Put here the vector of outcomes y (from matched$outcome.died) of those in the treatment group
y_trt <- matched$outcome.died[matched$treatment==1]
# Put here the vector of outcomes y (from matched$outcome.died) of those in the control group
y_con <- matched$outcome.died[matched$treatment==0]
print("===================================================")
diffy <- y_trt-y_con # pairwise difference
t.test(diffy)
print('The p-value is below 0.05.')
table(y_trt,y_con)
# In this table you will see the 2x2 table:
#         y_con
# ytreat     0     1
#       0    a     b
#       1    c     d
# Enter these a, b, c, and d numbers in the following McNemar test
# print("===================================================")
mcnemar.test(matrix(c(362,336,531,955 ),2,2)) # => Complete the command by filling the a, b, c, and d numbers in the correct order.
# => Is the p-value less than 0.05? What does this result mean?
print("The p-value is below 0.05. This means we reject H0, the treatment did have an effect")
# print("===================================================")
gmodel1 <- glm(outcome.died ~ treatment.swang, family=binomial, data=matched)
summary(gmodel1)
exp(coef(gmodel1)) ## 1.47 odds ratio for treatment         ################### CHECK AGAIN #################
print("===================================================")
# => Is the coefficient of treatment significant? you can use summary(gmodel1) or confint(gmodel1)
print("the coefficient of treatment is significant, since it has a p-value of 9.38e-10")
# =>  What is the odds ratio that is associated with treatment? You can easily derive it from the coefficient (Google otherwise how to get the odds ratio from the coefficient)
print("the odds ratio associated with treatment, calculated by exp(coefficient), is 1.47")
# =>  If the coefficient is positive, what does that mean in terms of odds ratio?
print("A positive coefficient implies that the odds ratio is above 1, in this context meaning treatment is associated with higher outcome of death.")
# => If the coefficient is negative, what does that mean in terms of odds ratio?
print("A negative coefficient implies that the odds ratio is below 1, in this context meaning treatment is associated with lower outcome of death.")
## Does this make sense?                            ################### CHECK AGAIN #################
# The great thing about modelling is that we can now again adjust for the variables with the worst SMD. Adjust for the variable with the worst SMD that you encountered before. To adjust you just add the name of the variable in the logistic regression formula. => Complete the command
gmodel2 <- glm(outcome.died ~ treatment.swang + aps1, family=binomial, data=matched)
exp(coef(gmodel2))
# => What is the odds ratio for treatment now?
print("When adjusting the variable 'aps1', the odds ratio of the treatment is ~1.24")
# print("===================================================")
print("===================================================")
# => Use the variables we found before in xvars in the first assignment to predict treatment
form <- reformulate(xvars, response = "treatment.swang")
psmodel <- glm(formula=form , family=binomial, data=rhc.selected)
print("===================================================")
summary(psmodel)   # show coefficients etc
pscore <- psmodel$fitted.values # create propensity score
#print(pscore)
prs_df <- data.frame(pr_score = predict(psmodel, type = "response"),
treatment = psmodel$model$treatment.swang)
#tail(prs_df)
print("===================================================")
#  => plot the density of the propensity scores of the treated and untreated. Tip: you might want to use par(mfrow=c(2,1)) to create 2 panels (2 rows, 1 column) and then plotting the first hist, with say, ylim=c(0,650) and col='darkblue', and the second histogram with ylim=c(650, 0) (note that we flipped the order) and col='darkblue'. This will plot the blue histogram as a normal histogram and the red one will be plotted upside down underneath the blue one so you can easily see the overlap.
gotTreatment <- prs_df$pr_score[prs_df$treatment==1]
gotNoTreatment <- prs_df$pr_score[prs_df$treatment==0]
par(mfrow=c(2,1))
hist(gotTreatment, ylim=c(0,650), col='darkblue')
hist(gotNoTreatment, ylim=c(650,0), col='red')
# => What do you think about the overlap?
print("This overlap makes sense, since we applied stratification methods. I assume anyways???")   ################### CHECK   AGAIN#################
print("===================================================")
print("===================================================")
# => Complete this function to calculate the log odds
logit <- function(p) {
return(log(p/(1-p)))
}
print("===================================================")
print("===================================================")
# => Check the overlap between the propensity scores for the two groups. What do you think about the overlap?
logitTreatment <- logit(gotTreatment)
logitNoTreatment <- logit(gotNoTreatment)
par(mfrow=c(2,1))
hist(logitTreatment, ylim=c(0,650), col='darkblue')
hist(logitNoTreatment, ylim=c(650,0), col='red')
print("There is partial overlap.")     ################### CHECK AGAIN x axes #################
print("===================================================")
print("===================================================")
# => complete the command
#mydata <- rhc.selected
##mydata$treatment <- matched$treatment.swang==1
#psmatch <- Match(Tr=mydata$treatment, M=1, X=logit(pscore), replace=FALSE, caliper = .2)
psmatch <- Match(Tr=rhc.selected$treatment.swang, M=1, X=logit(pscore), replace=FALSE, caliper = .2)
matched <- rhc.selected[unlist(psmatch[c("index.treated","index.control")]), ]
print("===================================================")
print("===================================================")
# => Complete the command
print(xvars)
matchedtab1 <- CreateTableOne(vars=xvars, strata = "treatment.swang",
data=matched, test = FALSE)
# => print the matching table showing the SMD
print(matchedtab1, smd = TRUE)
# => Are there any variables with bad balance now?
addmargins(table(ExtractSmd(matchedtab1) > 0.2))
print("There are still 3 variables with bad balance: aps1, meanbp1 , crea1.")
print("===================================================")
print("===================================================")
# => Put here the vector of outcomes y (from matched$outcome.died) of those in the treatment group
y_trt.ps <- matched$outcome.died[matched$treatment==1]
# Put here the vector of outcomes y (from matched$outcome.died) of those in the control group
y_con.ps <- matched$outcome.died[matched$treatment==0]
print("===================================================")
# Perform paired t-test. Just to get a feeling of the result
diffy.ps <- y_trt.ps - y_con.ps # pairwise difference
t.test(diffy.ps)
print("===================================================")
# => Is the test significant?
print('The test is significant since p-value=2.855e-11 so below 0.05.')
print("===================================================")
table(y_trt.ps,y_con.ps)  #added to visualize the 2x2 table
print("===================================================")
# => Complete the command
mcnemar.test(matrix(c(955,531,336,362 ),2,2))
# => Is the p-value less than 0.05? What does this result mean?
print("The p-value is 4.44e-11 so less than 0.05.")               ################### CHECK AGAIN #################
# => Compare the difference in the means before and after matching.
print("The difference in the means before and after ....")          ################### CHECK AGAIN #################
print("===================================================")
gmodel3 <- glm(outcome.died ~ treatment.swang, family="binomial", data = matched)
summary(gmodel3)
exp(coef(gmodel3))
print("===================================================")
# => What is the odds ratio of treatment?
print("The odds ratio of treatment is 1.27")                ################### CHECK AGAIN, same as 1st #################
# => Now correct also for the least well balanced variable
gmodel3 <- glm(outcome.died ~ treatment.swang + aps1, family="binomial", data = matched)
exp(coef(gmodel3))
# => What is the odds ratio of treatment now?
print("The odds ratio of treatment is now ~ 1.29")              ################### CHECK AGAIN, same as 1st ###############
print("===================================================")
View(prs_df)
View(prs_df)
View(prs_df)
View(prs_df)
#1. calculate the propensity score use any machine learning technique
#install.packages("MatchIt")          #install package if need it
#install.packages("rpart.plot")       #install package if need it
#We chose Random Forest since tree based methods have a better ability to detect non-linearity.
library(randomForest)
#1. calculate the propensity score use any machine learning technique
#install.packages("MatchIt")          #install package if need it
#install.packages("rpart.plot")       #install package if need it
install.packages('randomForest')
#We chose Random Forest since tree based methods have a better ability to detect non-linearity.
library(randomForest)
library("MatchIt")  #not sure if we are allowed to use it        ############## CHECK IT LATER ###########
#1. calculate the propensity score use any machine learning technique
install.packages("MatchIt")          #install package if need it
#install.packages("rpart.plot")       #install package if need it
install.packages('randomForest')
#We chose Random Forest since tree based methods have a better ability to detect non-linearity.
library(randomForest)
library("MatchIt")  #not sure if we are allowed to use it        ############## CHECK IT LATER ###########
set.seed(14)
rhc.rf <- rhc.selected
rhc.rf$treatment.swang <- as.factor(rhc.rf$treatment.swang)
rfFormula <- reformulate(xvars, response = "treatment.swang")
RFmodel <- randomForest(formula = rfFormula, data=rhc.rf, ntree=500, max_depth=1000)
